# not a TODO
skip module Data.Data

# Use compcert’s fixed width integers for the bit arrays in the Tip,
# but not for the mask in the Bin
rename type Data.IntSet.Internal.Nat = Int64.int
rename type Data.IntSet.Internal.BitMap = Int64.int
skip Int64.int
skip module Int64
rename type Data.IntSet.Internal.Mask = GHC.Num.Int
skip GHC.Num.Int

# These are TODOs:

# mutual recursion
skip Data.IntSet.Internal.fromDistinctAscList
skip Data.IntSet.Internal.fromAscList

# local termination via the bit mask
nonterminating Data.IntSet.Internal.foldlBits
nonterminating Data.IntSet.Internal.foldl'Bits
nonterminating Data.IntSet.Internal.foldrBits
nonterminating Data.IntSet.Internal.foldr'Bits

# Need to be implemented
rename value Utils.Containers.Internal.BitUtil.shiftLL = Data.IntSet.Internal.shiftLL
rename value Utils.Containers.Internal.BitUtil.shiftRL = Data.IntSet.Internal.shiftRL
rename value Utils.Containers.Internal.BitUtil.highestBitMask = Data.IntSet.Internal.highestBitMask
rewrite forall x y, Utils.Containers.Internal.BitUtil.bitcount x y = GHC.Num.op_zp__ x (Data.Bits.popCount x)

# Avoid the natFromInt, and avoid using N’s complement
skip Data.IntSet.Internal.maskW
redefine Definition Data.IntSet.Internal.mask : GHC.Num.Int -> (GHC.Num.Int -> Prefix) :=
  fun i m => Coq.ZArith.BinInt.Z.land i (Coq.ZArith.BinInt.Z.lxor (Coq.ZArith.BinInt.Z.lnot (Coq.ZArith.BinInt.Z.pred m)) m).


# We need to change or remove the type signature (body untouched)
redefine Definition Data.IntSet.Internal.maskW :=
  fun i m =>
    Coq.ZArith.BinInt.Z.of_N (i Data.Bits..&. (Data.Bits.xor
                             (Data.Bits.complement (m GHC.Num.- (GHC.Num.fromInteger 1))) m)).
redefine Definition Data.IntSet.Internal.natFromInt : GHC.Num.Int -> N :=
  fun i => GHC.Real.fromIntegral i.

# partial
skip Data.IntSet.Internal.findMax
skip Data.IntSet.Internal.findMin
skip Data.IntSet.Internal.maxView
skip Data.IntSet.Internal.deleteMax
skip Data.IntSet.Internal.deleteFindMax
skip Data.IntSet.Internal.minView
skip Data.IntSet.Internal.deleteMin
skip Data.IntSet.Internal.deleteFindMin

# Redefine branchMask. It uses [highestBitMask], which is usually used on the
# bitmasks (Int64), but branchMask is used on the unbounded integers that we store in the
# map.
redefine Definition Data.IntSet.Internal.branchMask : Prefix -> (Prefix -> GHC.Num.Int) :=
  fun p1 p2 => Coq.ZArith.BinInt.Z.pow 2 (Coq.ZArith.BinInt.Z.log2 (Coq.ZArith.BinInt.Z.lxor p1 p2)).

# Defined inthe midabmle
skip Data.IntSet.Internal.indexOfTheOnlyBit

#redefine Definition Data.IntSet.Internal.lowestBitMask : Nat -> Nat :=
#  fun n => Data.IntSet.Internal.revNatSafe (Data.IntSet.Internal.highestBitMask (Data.IntSet.Internal.revNatSafe n)).

# the revNat function is only correct if its result is cropped to 64 bits.
#add Data.IntSet.Internal Definition Data.IntSet.Internal.revNatSafe n := Coq.NArith.BinNat.N.modulo (Data.IntSet.Internal.revNat n) (Coq.NArith.BinNat.N.pow 2 64).
# Use rewrite, not rename, to not change the name of the actual definition
#rewrite forall, Data.IntSet.Internal.revNat = Data.IntSet.Internal.revNatSafe



# A bitmask adressing the last 6 bits of an int.
# This is the only place where otherwise the FiniteBits class is used
skip Data.IntSet.Internal.suffixBitMask

# These are typical that they recurse left or right
termination Data.IntSet.Internal.union        {measure ((size_nat arg_0__) + (size_nat arg_1__))}
obligations Data.IntSet.Internal.union        termination_by_omega
termination Data.IntSet.Internal.difference   {measure ((size_nat arg_0__) + (size_nat arg_1__))}
obligations Data.IntSet.Internal.difference   termination_by_omega
termination Data.IntSet.Internal.intersection {measure ((size_nat arg_0__) + (size_nat arg_1__))}
obligations Data.IntSet.Internal.intersection termination_by_omega
termination Data.IntSet.Internal.disjoint     {measure ((size_nat arg_0__) + (size_nat arg_1__))}
obligations Data.IntSet.Internal.disjoint     termination_by_omega

# Show stuff
skip Data.IntSet.Internal.showsBars
skip Data.IntSet.Internal.showsBitMap
skip Data.IntSet.Internal.showBitMap
skip Data.IntSet.Internal.showsTreeHang
skip Data.IntSet.Internal.showTreeWith
skip Data.IntSet.Internal.showBin
skip Data.IntSet.Internal.showWide
skip Data.IntSet.Internal.withBar
skip Data.IntSet.Internal.withEmpty
skip Data.IntSet.Internal.showsTree
skip Data.IntSet.Internal.showTree

# Data stuff
skip Data.IntSet.Internal.fromListConstr
skip Data.IntSet.Internal.intSetDataType
skip Data.IntSet.Internal.Monoid__IntSet


# We need Integral N to use GHC.Real.fromIntegral to go from N to Z
rename value Data.IntSet.Internal.intFromNat = Coq.ZArith.BinInt.Z.of_N
skip Coq.ZArith.BinInt.Z.of_N

skip module Coq.ZArith.BinInt.Z
skip module Coq.NArith.BinNat.N
